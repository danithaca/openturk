<?php

/**
 * This module provides a simple way to create commands for external programs/scripts to execute.
 *
 * @author Daniel Zhou <http://drupal.org/user/112233>
 */

/**
 * add a command
 * @return the ID of the newly created async command.
 */
function async_command_create_command($app, $command, $options = array()) {
  global $user;
  $uid = isset($options['uid']) ? $options['uid'] : $user->uid;
  $eid = isset($options['eid']) ? $options['eid'] : 0;

  if (!isset($options['avoid_duplicate']) || $options['avoid_duplicate']!=FASLE) {
    // check whether there's duplicate
    $result = db_query("SELECT id FROM {async_command} WHERE status IS NULL AND app=? AND command=? AND uid=? AND eid=?",
        array($app, $command, $uid, $eid));
    if ($result->rowCount() > 0) {
      // if duplicate exists, then just return.
      watchdog('async_command', 'duplicate command "!command" for application "!app"', array('!command'=>$command, '!app'=>$app));
      return;
    }
  }
  //$timestamp = date('c');
  $timestamp = time();
  $id = db_insert('async_command')
    ->fields(array(
      'app' => $app,
      'uid' => $uid,
      'eid' => $eid,
      'command' => $command,
      'created' => isset($options['created']) ? $options['created'] : $timestamp,
      'changed' => isset($options['changed']) ? $options['changed'] : $timestamp,
    ))
    ->execute();

  return $id;
}


function _async_command_table_fields() {
  return array(
    'id' => t('ID'),
    'app' => t('App'),
    'uid' => t('User'),
    'eid' => t('Entity ID'),
    'command' => t('Command'),
    'created' => t('Created'),
    'changed' => t('Updated'),
    'status' => t('Status'),
    'message' => t('Message'),
  );
}

/**
 * Retrieve a list of commands given the conditions, in an array list.
 */
function async_command_retrieve_command_list($app=NULL, $uid=NULL, $eid=NULL, $limit = 10) {
  $query = db_select('async_command', NULL, array('fetch' => PDO::FETCH_ASSOC));
  $query->fields('async_command', array_keys(_async_command_table_fields()));

  if ($app != NULL) {
    if (is_array($app)) {
      $query->condition('app', $app, 'IN');
    } else {
      $query->condition('app', $app, '=');
    }
  }
  if ($uid != NULL) {
    $query->condition('uid', $uid);
  }
  if ($eid != NULL) {
    $query->condition('eid', $eid);
  }
  $query->orderBy('created', 'DESC');
  $query->range(0, $limit);
  return $query->execute();
}


function async_command_theme($existing, $type, $theme, $path) {
  return array(
    'async_command_list' => array(
      'variables' => array(
        'title' => t('Recent command list'),
        'command_list' => NULL,
        'cols' => array_keys(_async_command_table_fields()),
      ),
    ),
    'async_command_operations' => array(
      'variables' => array(
        'title' => t('Operations'),
        'operations' => NULL,
      ),
    ),
  );
}

/**
 * @param  $variables a list of command, returned by async_command_retrieve_command_list
 * @return themed HTML string for the recent command list
 */
function theme_async_command_list($variables) {
  $table_fields = _async_command_table_fields();
  $cols = $variables['cols'];
  $command_list = $variables['command_list'];

  $header = array();
  foreach ($cols as $col) {
    $header[] = $table_fields[$col];
  }

  $rows = array();
  foreach ($command_list as $command) {
    // pre-process the command
    $command['command'] = check_plain($command['command']);
    $command['uid'] = $command['uid'] == 0 ? t('Anonymous') : user_load($command['uid'])->name;
    $command['created'] = format_date($command['created'], 'short');
    $command['changed'] = format_date($command['changed'], 'short');
    $command['status'] = isset($command['status']) ? ( $command['status'] == 1 ? t('success') : '<em>'. t('failure') .'</em>') : '&lt;'. t('pending...') .'&gt;';
    $command['message'] = check_plain($command['message']);

    $row = array();
    foreach ($cols as $col) {
      $row[] = $command[$col];
    }
    $rows[] = $row;
  }

  $table = array(
    'header' => $header,
    'rows' => $rows,
    //'caption' => t('Recent Commands List'),
    'empty' => t('No commands.')
  );
  $table_content = theme('table', $table);
  $title = check_plain($variables['title']);

  return "<div id='async-command-list'><h2 class='title'>$title</h2>{$table_content}</div>";

}


function theme_async_command_operations($variables) {
  $operations = $variables['operations'];
  $items = array();
  foreach ($operations as $path => $operation) {
    // note: in hook_menu, 'title' is untranslated, so we need to translate here.
    // TODO: need to make it look better (description should have smaller font)
    $item = l(t($operation['title']), $path);
    if (isset($operation['description'])) {
      $item .= " (". t($operation['description']) .")";
    }
    $items[] = $item;
  }
  $items_content = theme('item_list', array('items' => $items, 'type' => 'ul'));
  $title = $variables['title'];
  return "<div id='async-command-operations'><h2 class='title'>$title</h2>{$items_content}</div>";
}


//TODO: Need to add list/add command interface for users who have permissions.

/**
 * Implements hook_trigger_info().
 */
function async_command_trigger_info() {
  return array(
    'async_command' => array(
      'command_executed' => array(
        'label' => t('After the command was executed'),
      ),
      'command_failed' => array(
        'label' => t('After the command was executed, but failed'),
      ),
    ),
  );
}

/**
 * This trigger would be triggered in CRON for now.
 */
function async_command_fire_trigger($trigger_name, $command) {
  // trigger is optional
  if (!module_exists('trigger')) {
    return;
  }
  // Ask the trigger module for all actions enqueued for the 'triggersomething' trigger.
  $aids = trigger_get_assigned_actions($trigger_name);
  $context = array(
    'group' => 'async_command',
    'hook' => 'fire_trigger',
  );

  if ($command->uid != 0) {
    $context['user'] = user_load($command->uid);
  }
  if ($command->eid != 0) {
    // TODO: we use eid (for entity), but here used node_load(). should use entity_load() at some point
    $context['node'] = node_load($command->eid);
  }

  actions_do(array_keys($aids), NULL, $context);
}

/**
 * Implements hook_cron().
 */
function async_command_cron() {
  $cron_last = variable_get('cron_last', 0);
  // search all commands finished from the last cron
  $result = db_query("SELECT * FROM {async_command} WHERE status IS NOT NULL AND changed>=?", array($cron_last));

  foreach ($result as $record) {
    // fire the 'command_executed trigger for sure.
    async_command_fire_trigger('command_executed', $record);
    // fire 'command_failed' only when status=0
    if ($record->status == 0) {
      async_command_fire_trigger('command_failed', $record);
    }
  }
}